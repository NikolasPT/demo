<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Tic Tac Toe</title>
  <style>
    :root {
      --bg: #0f1724;
      --accent: #7c3aed;
      --x: #e11d48;
      --o: #06b6d4;
      --muted: #94a3b8;
      --win-bg: rgba(28,197,138,0.12);
      color-scheme: dark;

      --mark-min: 2rem;
      --mark-vw-factor: 10vw;
      --mark-max: 7rem;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system,
        "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      background: linear-gradient(180deg, var(--bg), #071021 120%);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px;
      color: #e6eef8;
      transition: background 220ms ease, color 220ms ease;
    }

    .ttt__container {
      width: 100%;
      max-width: 720px;
      background: linear-gradient(
        180deg,
        rgba(255,255,255,0.02),
        rgba(255,255,255,0.01)
      );
      border-radius: 12px;
      padding: 20px 20px 28px;
      box-shadow: 0 6px 30px rgba(2,6,23,0.6);
      transition: background 220ms ease, color 220ms ease,
        box-shadow 220ms ease;
    }

    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
      margin-bottom: 14px;
    }

    h1 {
      font-size: 20px;
      margin: 0;
    }

    .ttt__status {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
    }

    .ttt__status-msg {
      font-weight: 600;
    }

    .ttt__status-sub {
      font-size: 13px;
      color: var(--muted);
    }

    .ttt__board {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      margin: 18px 0;
    }

    .ttt__cell {
      aspect-ratio: 1/1;
      padding: 0;
      border-radius: 10px;
      border: 2px solid rgba(255,255,255,0.04);
      background: linear-gradient(
        180deg,
        rgba(255,255,255,0.01),
        transparent
      );
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: clamp(var(--mark-min), var(--mark-vw-factor), var(--mark-max));
      line-height: 1;
      font-weight: 700;
      color: var(--muted);
      cursor: pointer;
      transition: transform 0.08s ease, background 0.12s,
        border-color 180ms ease, color 180ms ease;
      user-select: none;
    }

    .ttt__cell:hover {
      transform: translateY(-3px);
    }

    .ttt__cell:focus {
      outline: 3px solid rgba(124,58,237,0.18);
      transform: scale(1.02);
    }

    .ttt__cell--x {
      color: var(--x);
    }

    .ttt__cell--o {
      color: var(--o);
    }

    .ttt__cell--win {
      background: var(--win-bg);
      box-shadow: 0 6px 18px rgba(2,6,23,0.6) inset;
      animation: win-pulse 1200ms ease-in-out infinite;
    }

    @keyframes mark-pop {
      0% {
        transform: scale(0.4) rotate(-10deg);
        opacity: 0;
      }
      60% {
        transform: scale(1.08) rotate(4deg);
        opacity: 1;
      }
      100% {
        transform: scale(1) rotate(0deg);
        opacity: 1;
      }
    }

    .ttt__cell--placed {
      animation: mark-pop 300ms cubic-bezier(.2,.9,.2,1) both;
    }

    @keyframes win-pulse {
      0% {
        box-shadow: 0 6px 18px rgba(2,6,23,0.6) inset;
      }
      50% {
        box-shadow: 0 12px 32px rgba(124,58,237,0.12) inset;
      }
      100% {
        box-shadow: 0 6px 18px rgba(2,6,23,0.6) inset;
      }
    }

    @keyframes hint-pulse {
      0% {
        transform: scale(1);
        opacity: 1;
        box-shadow: none;
      }
      50% {
        transform: scale(1.04);
        opacity: 0.98;
        box-shadow: 0 0 10px rgba(124,58,237,0.04);
      }
      100% {
        transform: scale(1);
        opacity: 1;
        box-shadow: none;
      }
    }

    .ttt__cell--hint {
      animation: hint-pulse 700ms ease-in-out infinite;
      border-color: rgba(124,58,237,0.22);
      will-change: transform, opacity;
    }

    @media (prefers-reduced-motion: reduce) {
      .ttt__cell--placed,
      .ttt__cell--hint,
      .ttt__cell--win {
        animation: none !important;
      }
    }

    .ttt__controls {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    .ttt__btn {
      background: transparent;
      border: 1px solid rgba(255,255,255,0.06);
      color: inherit;
      padding: 8px 12px;
      border-radius: 8px;
      cursor: pointer;
      transition: background 160ms ease, border-color 160ms ease,
        color 160ms ease;
    }

    .ttt__btn--primary {
      background: linear-gradient(90deg, var(--accent), #4f46e5);
      border: none;
      color: white;
    }

    .ttt__score {
      display: flex;
      gap: 12px;
      align-items: center;
      color: var(--muted);
      font-size: 14px;
    }

    .ttt__score-item {
      display: inline-flex;
      gap: 6px;
      align-items: center;
      background: rgba(255,255,255,0.02);
      padding: 6px 8px;
      border-radius: 8px;
    }

    .ttt__ai-controls {
      display: inline-flex;
      gap: 8px;
      align-items: center;
      margin-left: 12px;
    }

    .ttt__ai-controls label {
      font-size: 13px;
      color: var(--muted);
      display: inline-flex;
      gap: 6px;
      align-items: center;
    }

    .ttt__select {
      background: transparent;
      color: inherit;
      border: 1px solid rgba(255,255,255,0.06);
      padding: 6px 8px;
      border-radius: 8px;
      font-size: 13px;
    }

    @media (max-width: 420px) {
      :root {
        --mark-vw-factor: 18vw;
      }

      h1 {
        font-size: 16px;
      }

      .ttt__controls {
        flex-direction: column;
        align-items: stretch;
      }

      .ttt__ai-controls {
        margin-left: 0;
      }
    }
  </style>
</head>
<body>
  <main class="ttt__container">
    <header>
      <h1>Tic Tac Toe</h1>

      <div class="ttt__status">
        <div
          id="statusMsg"
          class="ttt__status-msg"
          aria-live="polite"
        >
          Player X's turn
        </div>
        <div class="ttt__status-sub">
          Click a cell or use keyboard (Tab + Enter/Space)
        </div>
      </div>
    </header>

    <section
      class="ttt__board"
      role="grid"
      aria-label="Tic Tac Toe board"
    >
      <button
        class="ttt__cell"
        data-index="0"
        role="gridcell"
        aria-label="Row 1, Column 1, empty"
        aria-pressed="false"
      ></button>
      <button
        class="ttt__cell"
        data-index="1"
        role="gridcell"
        aria-label="Row 1, Column 2, empty"
        aria-pressed="false"
      ></button>
      <button
        class="ttt__cell"
        data-index="2"
        role="gridcell"
        aria-label="Row 1, Column 3, empty"
        aria-pressed="false"
      ></button>

      <button
        class="ttt__cell"
        data-index="3"
        role="gridcell"
        aria-label="Row 2, Column 1, empty"
        aria-pressed="false"
      ></button>
      <button
        class="ttt__cell"
        data-index="4"
        role="gridcell"
        aria-label="Row 2, Column 2, empty"
        aria-pressed="false"
      ></button>
      <button
        class="ttt__cell"
        data-index="5"
        role="gridcell"
        aria-label="Row 2, Column 3, empty"
        aria-pressed="false"
      ></button>

      <button
        class="ttt__cell"
        data-index="6"
        role="gridcell"
        aria-label="Row 3, Column 1, empty"
        aria-pressed="false"
      ></button>
      <button
        class="ttt__cell"
        data-index="7"
        role="gridcell"
        aria-label="Row 3, Column 2, empty"
        aria-pressed="false"
      ></button>
      <button
        class="ttt__cell"
        data-index="8"
        role="gridcell"
        aria-label="Row 3, Column 3, empty"
        aria-pressed="false"
      ></button>
    </section>

    <div class="ttt__controls">
      <div class="ttt__score">
        <span id="scoreX" class="ttt__score-item">X: 0</span>
        <span id="scoreO" class="ttt__score-item">O: 0</span>
        <span id="scoreD" class="ttt__score-item">Draws: 0</span>
      </div>

      <div>
        <button id="newGame" class="ttt__btn ttt__btn--primary">
          New Game
        </button>
        <button id="resetScores" class="ttt__btn" title="Reset scores">
          Reset Scores
        </button>

        <span class="ttt__ai-controls">
          <label>
            <input
              id="vsComputer"
              type="checkbox"
              aria-label="Play vs Computer"
            />
            Play vs Computer
          </label>

          <label>
            <span class="ttt__status-sub">Side:</span>
            <select
              id="computerSide"
              class="ttt__select"
              aria-label="Computer plays as X or O"
            >
              <option value="X">X</option>
              <option value="O" selected>O</option>
            </select>
          </label>
        </span>
      </div>
    </div>
  </main>

  <script>
    (function () {
      // DOM references
      const cellEls = Array.from(document.querySelectorAll('.ttt__cell'));
      const statusEl = document.getElementById('statusMsg');
      const newGameBtn = document.getElementById('newGame');
      const resetScoresBtn = document.getElementById('resetScores');
      const scoreXEl = document.getElementById('scoreX');
      const scoreOEl = document.getElementById('scoreO');
      const scoreDEl = document.getElementById('scoreD');
      const vsComputerCheckbox = document.getElementById('vsComputer');
      const computerSideSelect = document.getElementById('computerSide');

      // Winning combinations
      const WINNING_COMBOS = [
        [0, 1, 2],
        [3, 4, 5],
        [6, 7, 8],
        [0, 3, 6],
        [1, 4, 7],
        [2, 5, 8],
        [0, 4, 8],
        [2, 4, 6],
      ];

      // Game state
      let board = Array(9).fill('');
      let currentPlayer = 'X';
      let isGameActive = true;
      const SCORE = { X: 0, O: 0, draws: 0 };

      // Computer opponent state
      let vsComputer = false;
      let computerSide = 'O';
      let computerMoveTimeout = null;

      // Initialize app: attach listeners and render initial state
      function init() {
        cellEls.forEach(cell => {
          cell.addEventListener('click', onCellClick);
          cell.addEventListener('keydown', onCellKeyDown);
        });

        newGameBtn.addEventListener('click', resetGame);
        resetScoresBtn.addEventListener('click', resetScores);

        vsComputerCheckbox.addEventListener('change', (e) => {
          vsComputer = e.target.checked === true;
          computerSideSelect.disabled = !vsComputer;

          // If computer is enabled and it's computer's turn, trigger
          maybeTriggerComputerTurn();
        });

        computerSideSelect.addEventListener('change', (e) => {
          computerSide = e.target.value;

          // If computer now must play immediately, trigger
          maybeTriggerComputerTurn();
        });

        // set UI defaults
        vsComputerCheckbox.checked = vsComputer;
        computerSideSelect.value = computerSide;
        computerSideSelect.disabled = !vsComputer;

        updateStatus("Player " + currentPlayer + "'s turn");
        render();

        // If the computer should start (computerSide === 'X'), trigger
        maybeTriggerComputerTurn();
      }

      // Keyboard support: Enter/Space acts like click
      function onCellKeyDown(e) {
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          e.target.click();
        }
      }

      // Click handler for a cell
      function onCellClick(e) {
        const idx = Number(e.currentTarget.dataset.index);

        if (!isGameActive) return;

        // Prevent human from playing when it's computer's turn
        if (vsComputer && currentPlayer === computerSide) return;

        if (board[idx]) return;

        applyMoveAndAdvance(idx);
      }

      // Place move, animate, check win/draw and advance turn
      function applyMoveAndAdvance(idx) {
        board[idx] = currentPlayer;
        updateCellUI(idx, true);

        // Check for a win
        if (checkWin()) {
          isGameActive = false;
          const winnerLabel = (vsComputer && currentPlayer === computerSide)
            ? ('Computer (' + currentPlayer + ')')
            : ('Player ' + currentPlayer);

          updateStatus(winnerLabel + ' wins!');
          SCORE[currentPlayer] = SCORE[currentPlayer] + 1;
          updateScoreUI();

          // Clear pending timeouts and hints
          if (computerMoveTimeout) {
            clearTimeout(computerMoveTimeout);
            computerMoveTimeout = null;
          }

          removeAllHints();
          return;
        }

        // Check for a draw
        if (checkDraw()) {
          isGameActive = false;
          updateStatus('Draw!');
          SCORE.draws = SCORE.draws + 1;
          updateScoreUI();

          if (computerMoveTimeout) {
            clearTimeout(computerMoveTimeout);
            computerMoveTimeout = null;
          }

          removeAllHints();
          return;
        }

        // Continue game: switch player
        currentPlayer = currentPlayer === 'X' ? 'O' : 'X';

        if (vsComputer && currentPlayer === computerSide) {
          updateStatus("Computer's turn");
          maybeTriggerComputerTurn();
        } else {
          updateStatus('Player ' + currentPlayer + "'s turn");
        }
      }

      // Update a cell element: text, classes, aria attributes
      function updateCellUI(idx, animate = false) {
        const cell = cellEls[idx];

        cell.textContent = board[idx];

        cell.classList.remove('ttt__cell--x');
        cell.classList.remove('ttt__cell--o');

        if (board[idx]) {
          cell.classList.add('ttt__cell--' + board[idx].toLowerCase());
        }

        const row = Math.floor(idx / 3) + 1;
        const col = (idx % 3) + 1;

        cell.setAttribute(
          'aria-label',
          'Row ' + row + ', Column ' + col + ', ' + (board[idx] || 'empty')
        );

        cell.setAttribute('aria-pressed', board[idx] ? 'true' : 'false');

        if (animate && board[idx]) {
          // Re-trigger placed animation reliably
          cell.classList.remove('ttt__cell--placed');
          void cell.offsetWidth; // force reflow
          cell.classList.add('ttt__cell--placed');

          const onAnimEnd = () => {
            cell.classList.remove('ttt__cell--placed');
          };

          cell.addEventListener('animationend', onAnimEnd, { once: true });
        }
      }

      // Check for win and highlight winning cells
      function checkWin() {
        for (const combo of WINNING_COMBOS) {
          const a = combo[0];
          const b = combo[1];
          const c = combo[2];

          if (
            board[a] &&
            board[a] === board[b] &&
            board[a] === board[c]
          ) {
            highlightWin(combo);
            return true;
          }
        }

        return false;
      }

      function highlightWin(combo) {
        combo.forEach(i => {
          cellEls[i].classList.add('ttt__cell--win');
        });
      }

      function checkDraw() {
        return board.every(cell => {
          return cell;
        });
      }

      function updateStatus(text) {
        statusEl.textContent = text;
      }

      // Reset the board for a new game but preserve scores
      function resetGame() {
        if (computerMoveTimeout) {
          clearTimeout(computerMoveTimeout);
          computerMoveTimeout = null;
        }

        board = Array(9).fill('');
        currentPlayer = 'X';
        isGameActive = true;

        cellEls.forEach((cell, i) => {
          cell.textContent = '';
          cell.classList.remove('ttt__cell--x');
          cell.classList.remove('ttt__cell--o');
          cell.classList.remove('ttt__cell--win');
          cell.classList.remove('ttt__cell--placed');
          cell.classList.remove('ttt__cell--hint');

          const r = Math.floor(i / 3) + 1;
          const c = (i % 3) + 1;
          cell.setAttribute('aria-label', 'Row ' + r + ', Column ' + c + ', empty');
          cell.setAttribute('aria-pressed', 'false');
        });

        updateStatus("Player " + currentPlayer + "'s turn");

        // Move focus to first cell for keyboard users
        cellEls[0].focus();

        // If the computer should start after reset, trigger it
        maybeTriggerComputerTurn();
      }

      function resetScores() {
        SCORE.X = 0;
        SCORE.O = 0;
        SCORE.draws = 0;
        updateScoreUI();
      }

      function updateScoreUI() {
        scoreXEl.textContent = 'X: ' + SCORE.X;
        scoreOEl.textContent = 'O: ' + SCORE.O;
        scoreDEl.textContent = 'Draws: ' + SCORE.draws;
      }

      // AI helpers
      function getAvailableMoves() {
        const moves = [];
        board.forEach((v, i) => { if (!v) moves.push(i); });
        return moves;
      }

      function findWinningMoveFor(player) {
        for (const combo of WINNING_COMBOS) {
          const [a, b, c] = combo;
          const vals = [board[a], board[b], board[c]];

          // If two are player's and one is empty -> winning/blocking move
          const countPlayer = vals.filter(v => v === player).length;
          const emptyIndex = combo.find(i => !board[i]);

          if (countPlayer === 2 && emptyIndex !== undefined) {
            return emptyIndex;
          }
        }
        return null;
      }

      // Deterministic tentative move for hinting
      function computeTentativeComputerMove() {
        const opponent = computerSide === 'X' ? 'O' : 'X';

        // Priority order: win > block > center > corner > fallback
        let move = findWinningMoveFor(computerSide);
        if (move === null) move = findWinningMoveFor(opponent);
        if (move === null && !board[4]) move = 4;
        const corners = [0,2,6,8].filter(i => !board[i]);
        if (move === null && corners.length) move = corners[0];
        const avail = getAvailableMoves();
        if (move === null && avail.length) move = avail[0];

        return move;
      }

      function removeAllHints() {
        cellEls.forEach(c => c.classList.remove('ttt__cell--hint'));
      }

      // If it's computer's turn, show a hint and schedule the move
      function maybeTriggerComputerTurn() {
        // Clear previous scheduled move/hint
        if (computerMoveTimeout) {
          clearTimeout(computerMoveTimeout);
          computerMoveTimeout = null;
        }

        removeAllHints();

        if (!vsComputer || !isGameActive) return;
        if (currentPlayer !== computerSide) return;

        updateStatus("Computer's turn");

        // Show tentative hint
        const tentative = computeTentativeComputerMove();
        if (tentative !== null && tentative !== undefined) {
          const target = cellEls[tentative];
          if (target && !board[tentative]) {
            target.classList.add('ttt__cell--hint');
          }
        }

        // Slight delay to make the computer feel natural; store timeout so
        // it can be cancelled if the user resets or toggles vsComputer.
        computerMoveTimeout = setTimeout(() => {
          computerMoveTimeout = null;
          removeAllHints();
          computerMakeMove();
        }, 350);
      }

      // Make the computer move. Similar priority to tentative but adds some
      // randomness among equal choices so the computer doesn't feel too
      // deterministic when multiple corners/slots are available.
      function computerMakeMove() {
        if (!isGameActive) return;
        if (!vsComputer) return;
        if (currentPlayer !== computerSide) return;

        removeAllHints();

        const opponent = currentPlayer === 'X' ? 'O' : 'X';

        let move = findWinningMoveFor(currentPlayer);
        if (move === null) move = findWinningMoveFor(opponent);
        if (move === null && !board[4]) move = 4;
        const corners = [0,2,6,8].filter(i => !board[i]);
        if (move === null && corners.length) {
          move = corners[Math.floor(Math.random() * corners.length)];
        }
        const avail = getAvailableMoves();
        if (move === null && avail.length) {
          move = avail[Math.floor(Math.random() * avail.length)];
        }

        if (move !== null && move !== undefined) {
          applyMoveAndAdvance(move);
        }
      }

      // Full render used at init/reset to sync DOM from state
      function render() {
        cellEls.forEach((cell, i) => {
          const val = board[i];

          cell.textContent = val;

          if (val) {
            cell.classList.add('ttt__cell--' + val.toLowerCase());
            cell.setAttribute('aria-pressed', 'true');

            const row = Math.floor(i / 3) + 1;
            const col = (i % 3) + 1;
            cell.setAttribute(
              'aria-label',
              'Row ' + row + ', Column ' + col + ', ' + val
            );
          } else {
            const row = Math.floor(i / 3) + 1;
            const col = (i % 3) + 1;
            cell.setAttribute(
              'aria-label',
              'Row ' + row + ', Column ' + col + ', empty'
            );
          }
        });

        updateScoreUI();
      }

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
      } else {
        init();
      }
    })();
  </script>
</body>
</html>
